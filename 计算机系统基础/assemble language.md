## 数据表示

### 数据类型

1. 字节 DB

   Define Byte,定义字节(8位/1字节)无符号整数;等同于BYTE;

2. 字 DW

   DW:Define Word,定义字(16位/2字节)无符号整数;等同于WORD;

3. 双字 DD

   DD:Define DoubleWord,定义双字(32位/4字节)无符号整数;等同于DWORD;

4. 三字 DF

   DF:Defined Farword,定义三字(48位/6字节)无符号整数;等同于FWORD;

5. 四字 DQ

   DQ:Define QuadWord,定义四字(64位/8字节)无符号整数;等同于QWORD;

6. 五字 DT

   DT:Define TenBytes,定义五字(80位/10字节)无符号整数;等同于TBYTE;

7. 字符串

   由若干个字节组成,字节数不定,通常每个字节存储一个字符;

   '$'为字符串结束符'\0',0DH是回车字符'\r',0AH是换行字符'\n'

### 转二进制

1. 用2整除十进制整数，得到一个商和余数；
2. 再用2去除商，又会得到一个商和余数，
3. 如此重复，直到商为小于1时为止，
4. 然后把先得到余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，以此排列起来。

注1：当一个整数除另一个整数得到整数商而没有余数时，叫做整除。如2除6得3，就说2能整除6或6能被2整除。

注2：除以是被除数在前，除数在后；除是除数在前，被除数在后。如32÷8=4可描述为：8除32等于4，或者32除以8等于4。

### 补码

1. 正数

   正数的补码，反码均与原码相同

   原码为数的二进制表示

2. 负数

   - 反码：原码除符号位以外，取反
   - 补码：反码+1

#### 补码运算

1. 补码加法

   [m+n]补 = \[m]补 + [n]补

2. 相反数的补码

   [-n]补 = [n]补 求补

   求补运算：求补运算不考虑符号位，对它的原码各位取反，并在末位加1而得到

3. 补码的减法

   [m-n]补 = [m]补 + [-n]补

### BCD码

1. 压缩BCD码

   用二进制表示每一位十进制数

   `9781 = 1001 0111 1000 0001`

2. 非压缩BCD码

   在每一位十进制数转化为二进制后，前面补0

   `9781 = 00001001 00000111 00001000 00000001 `

### 浮点数

$$
\pm(a_{n}2^n +...+ a_{1}2^1 + a_{0}2^0 + a_{-1}2^-1 + ... + a_{-m}2^{-m})
$$

#### 规格化数据

$$
 \pm1.XXX*2^n B
$$

科学表示法，小数点左边恒为1

要素

- 正负号
- 尾数 XXX
- 指数 n 单精度(-126 - 127)

#### 机内表示形式

![src=http://dandelioncloud.cn/images/20211013/5e02f8f57a4f40388dd37e39363115d2.png&refer=http://dandelioncloud.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto (1120×516) (baidu.com)](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdandelioncloud.cn%2Fimages%2F20211013%2F5e02f8f57a4f40388dd37e39363115d2.png&refer=http%3A%2F%2Fdandelioncloud.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1667313968&t=c1024b21d4064e459171e2ea7cf18968)

- 符号位 0为正数 1为负数
- 指数 采用**移码**表示
  - 单精度float移 7F
  - 双精度double移 3FF

##### 移码

移码常用来表示浮点数的阶码。它只能表示整数。
移码就是在真值x上加上一个常数（偏置值），相当于x在数轴上向正方向偏移了若干单位。

### 字符

1. 西文字符

   ASCII码

2. 汉字字符

   - GBK
   - Unicode



## 寻址方式

### Intel 80x86 内部结构

1. 数据寄存器组

   - EAX 累加器 Accumulator
   - EBX 基址寄存器 Base
   - ECX 计数寄存器 Count
   - EDX 数据寄存器 Data

2. 指示器变址寄存器组

   - ESI ：Source Index 源变址寄存器 
   - EDI ：Destination Index 目的变址寄存器
   - ESP ：Stack Pointer 堆栈指示器，存放当前堆栈栈顶的偏移地址
   - EBP ：Base Pointer 对**堆栈**操作的基址寄存器

3. 段寄存器

   保存当前可用段的段首地址

   计算物理地址时，应将段寄存器内容左移4位，然后再与偏移地址相加，得到待访问单元的物理地址

   **PA =** **段首址 \* 16** **+ 偏移地址**

   - 代码段寄存器 CS
   - 堆栈段寄存器 SS
   - 数据段寄存器 DS
   - 附加段寄存器
     - ES
     - FS
     - GS

### 寻址方式

1. 立即寻址

   操作数直接存放在指令中，紧跟在操作码之后，它作为指令的一部分存放在代码段里，这种操作数称为立即数，源操作数采用立即寻址

   汇编格式：**n**

   功能：指令的下一单元的内容为操作数n

   例子：`MOV AX, 3064H` 

   ​			目的操作数采用寄存器寻址，地址为AX。源操作数采用立即寻址

2. 寄存器寻址

   在这种寻址方式中，指令所指明的寄存器中存放操作数，目的操作数采用寄存器寻址

   汇编格式：**R**

   功能：寄存器R的内容就是操作数。

   例子：`INC AX` `ADD AX, BX` 

   ​			AX为目的操作数地址，BX为源操作数地址,目的操作数、源操作数都是用寄存器寻址

3. 直接寻址

   直接寻址方式中，操作数的偏移地址就在指令操作码后面，而操作数则存放在内存中。

   汇编格式：**段寄存器名：[EA] 或 地址表达式**

   功能：令下一字单元的内容是操作数的偏移地址

4. 寄存器间接寻址

   操作数的有效地址（偏移地址）在基址寄存器BX、BP或变址寄存器SI、DI中，而操作数则在存贮器中。

   格式：**[R]** (R只能是BP、BX、DI、SI之一。BP所指的段为堆栈段)

   功能：R的内容为操作数的偏移地址EA

   例子：`MOV AX, [SI]`

5. 变址寻址

   操作数的偏移地址EA是指令中指明的寄存器的内容与指令中给出的位移量之和。操作数在存贮器中。

   汇编格式：**[R+X] (或：[R]+X, 或X[R])**

   功能：R的内容与X相加，和为操作数的偏移地址EA。

   **寄存器的选择同寄存器间接寻址一样，只能是BP、BX、DI、SI之一。BP所指的段为堆栈段。**

   例子：`MOV AX, COUNT[SI]` 

6. 基址+变址寻址

   操作数的偏移地址EA是指令中指定的基址寄存器内容、变址寄存器内容及位移量X三者之和。操作数存放在主存之中。

   格式：**[BR+IR+X] (或：X\[BR][IR], 或 X[BR+IR])**

   ​		 (BR表示基址寄存器，只能是BX、BP之一。IR表示变址寄存器，只能是SI、DI之一）

   功能：BR的内容加上IR的内容，再加上X，得到操作数的偏移地址。也就是：EA =（BR）+（IR）+X。

### 常量与变量

#### 常量

常量：汇编时已有确定数值的量。

用途：赋值、作立即数、位移量。

分类

- 数值常量
  - 二进制
  - 八进制
  - 十六进制
  - 字符
- 符号常量
  - 有名字的数值常量

#### 数值表达式

常量与运算符组成的式子。数值表达式**在汇编期间进行运算**，结果为常量。

- 算术运算

  +、–、*、/、MOD(模除, 取余数)、 SHR(右移)、SHL(左移)。

- 逻辑运算

  - 逻辑乘：AND (与) ， 
  - 逻辑加：OR  (或) ，   
  - 按位加：XOR (异或) ，
  - 逻辑非：NOT  (非)

- 关系运算

  - 相等：EQ、
  - 不等： NE、
  - 小于：LT、
  - 大于： GT、     
  - 小于等于：LE、 
  - 大于等于: GE

  **运算结果：关系不成立，结果为0；关系成立，结果为–1**

#### 变量

数据段或附加数据段中一个数据存贮单元的名字, 是这个存储单元的地址的符号表示。可代表**一批存储单元的首址**。

##### 属性

- 段属性

  定义变量所在段的**段首址**，当访问该变量时该段首址应在某一段寄存器中，即为CPU当前可访问段;

- 偏移地址

  该变量**所占存储单元到所在段的段首址的字节距离**;

- 类型

  类型是指存取该变量中的数据所需要的**字节数**,变量的类型由定义该变量时所使用的伪指令确定

##### 定义

`[变量名] 数据定义伪指令 表达式[,...]`

- 数据定义伪指令：

​		DB、DW、DD、DQ和DT

- 表达式：
  1. 数值表达式
  2. ASCII字符串
  3. 地址表达式(DW 地址表达式为变量时，DW内容为变量的EA；DD 地址表达式为变量时，DD的内容为EA+段首址)
  4. ？值不确定
  5. n DUP(表达式)，重复子句

​	上述1 - 5组成的系列，各表达式之间用逗号隔开

#### 地址表达式

由变量、标号、常量、寄存器(名加方括号)及一些运算符(数值表达式的运算符和特殊运算符)所组成的有意义的式子。

地址表达式也具有**段、EA、类型**等三个属性。

简单的地址表达式：直接寻址、间接寻址、变址、基址加变址等

##### 属性定义符

1. 类型运算符 PTR

   功能：指明变量、标号或地址表达式的类型。

   格式：`类型  PTR  地址表达式`

   类型可以是：BYTE、WORD、DWORD、NEAR、FAR  

2. 跨段前缀符 ‘:’

3. 定义类型算符 THIS

##### 属性分离符

功能：分离出段、EA及类型等属性。分离对象为变量、标号。

格式：`属性分离算符 变量或标号`

1. 取偏移地址 OFFSET
2. 取段地址 SEG
3. 取类型 TYPE

## 常用指令

### 一般数据传送指令

1. 传送指令

   `MOV OPD,OPS`

   (OPS) -> OPD

2. 数据交换指令

   `XCHG OPD,OPS`

   (OPD)->OPS, (OPS)->OPD

3. 查表转换指令

   `XLAT OPS`

   ([BX+AL]) -> AL, 

   将（BX）为首址，（AL）为位移量的字节单元数据→AL

4. 符号扩展传送指令

   `MOVSX OPD, OPS`

   将源操作数的符号向前扩展成与目的操作数相同的数据类型后，再送入目的地址对应的单元中

5. 无符号扩展传送指令

   ``MOVZX OPD, OPS``

   将源操作数的**高位补0**，扩成与目的操作数相同的数据类型后，再送入目的地址对应的单元中

### 地址传送指令

1. 传送**偏移地址**指令

   `LEA OPD,OPS` 等价于 `MOV OPD, OFFSET OPS`

   OPS的偏移地址 -> OPD

2. 传送**偏移地址及数据首址**指令

   `LDS OPD,OPS`

   (OPS) -> OPD, (OPS+2) -> DS

   将OPS所指的4个字节内容送到OPD和DS

### 算术指令

1. 加法指令

   `ADD OPD,OPS`

   (OPS) + (OPD) -> OPD

   `INC OPD`

   (OPD) + 1 -> OPD

2. 减法指令

   `SUB OPD,OPS`

   (OPD) - (OPS) -> OPD

   `DEC OPD`

   (OPD) - 1 -> OPD

   `NEG OPD`

   () + 1-> OPD (求补)

   `CMP OPD,OPS`

   (OPD) - (OPS) 不回送结果，仅影响标记

3. 乘法指令

   被乘数隐含在AX(AL)中，由OPS决定是字乘法还是字节乘法

   `IMUL OPS`

   有符号乘法

   `MUL OPS`

   无符号乘法

   `IMUL OPD,OPS`

   (OPD)*(OPS) -> OPD

   `IMUL OPD,OPS n`

   (OPS) * n -> OPD

4. 符号扩展指令

   `CBW`

   字节转换为字

   将AL中的符号拓展到AH中

   `CWD`

   字转换为双字

   AX的符号拓展到DX

   `CWDE`

   字转换为双字

   AX拓展到EAX

5. 除法指令

   `IDIV OPS`

   有符号除法

   `DIV OPS`

   无符号除法

   字节除法：（AX）/（OPS）→AL（商）、AH（余数）

   字除法：（DX、AX）/（OPS）→AX（商）、DX（余）

   双字除法：（EDA、EAX）/（OPS）→EAX（商）、EDX（余）

### 位操作指令

#### 逻辑运算

1. 求反

   `NOT OPD`

2. 逻辑乘

   `AND OPD,OPS`

   OPD ^ OPS -> OPD，影响标志位

   `TEST OPD,OPS`

   结果不送回，只影响标志位

3. 逻辑加

   `OR OPD,OPS`

   (OPD) v (OPS) -> OPD，影响标志位

4. 按位加

   `XOR OPD,OPS`

#### 移位

`操作符 OPD,n`

1. SA 算术移位

   - SAL 左移一次，**最低位补0**，最高位送入CF标志位

     ![20180518192754723 (565×150) (csdn.net)](https://img-blog.csdn.net/20180518192754723)

   - SAR 右移一次，**最高位不变**，最低位送入CF标志位

     ![20180518193402161 (562×181) (csdn.net)](https://img-blog.csdn.net/20180518193402161)

2. SH 逻辑移位

   - SHL 同SAL

     ![20180518194010627 (553×133) (csdn.net)](https://img-blog.csdn.net/20180518194010627)

   - SHR 右移一次，**最高位补0**，最低位送入CF标志位

     ![20180518194349811 (520×164) (csdn.net)](https://img-blog.csdn.net/20180518194349811)

3. RO 循环移位

   - ROL 左移一次，左移前的最高位送入最低位以及CF

     ![20180518195037685 (527×162) (csdn.net)](https://img-blog.csdn.net/20180518195037685)

   - ROR 右移一次，右移前的最低位送入最高位及CF

     ![20180518195353507 (545×164) (csdn.net)](https://img-blog.csdn.net/20180518195353507)

4. RC 带进位循环移位

   - RCL 左移一次，左移前的最高位送入CF，CF的内容送入最低位

     ![20180518195732711 (563×162) (csdn.net)](https://img-blog.csdn.net/20180518195732711)

   - RCR 右移一次，右移前的最低位送入CF，CF的内容送入最高位

     ![20180518195856509 (562×174) (csdn.net)](https://img-blog.csdn.net/20180518195856509)

## 功能调用

### 调用过程

1. 功能号 -> AH
2. 设置好入口参数
3. 执行 INT 21H
4. 分析出口参数

### 键盘输入 1

```shell
MOV AH, 1
INT 21H
```

等待键盘输入一个字符，并将字符的ASCII码送到AL中，同时输入的字符在屏幕上显示

### 显示输出 2

```
MOV DL, 'A'
MOV AH, 2
INT 21H
```

将DL中的字符送显示器显示

### 输出字符串

```
LEA DX, 字符串首址偏移地址
MOV AH, 9
INT 21H
```

将当前数据区中，DS：DX所指的以’$’结束的字符串显示出来

```
LEA DX, 缓冲区首址偏移地址
MOV AH, 10
INT 21H
```

从键盘上向DS：DX所指的缓冲区输入字符串（有回显）

## 转移指令

改变程序的执行顺序，即改变**指令指示器IP**的内容

### 标志寄存器

保存一条指令运行之后，**CPU所处状态的信息**及**运算结果的特征**

1. 符号标志 SF (Sign Flag)

   运算结果的最高二进制位为1，则SF=1，否则SF=0

2. 进位标志 CF (Carry Flag)

   运算时从最高位向前产生了进位(或借位)，则CF=1，否则CF=0

3. 零标志 ZF (Zero Flag)

   运算结果为0，ZF=1，否则ZF=0

4. 溢出标志 OF (Overflow Flag)

   运算结果超出了有符号数的范围，则OF=1

   当出现`正+正=负、负+负=正、正-负=负、负-正=正`，产生溢出

5. 奇偶标志 PF 

   指令执行后，其结果的二进制表示中**1的个数是否为偶数**，若1的个数为偶数，PF=1；若1的个数为奇数，PF=0

### 条件转移

由上一条指令所设的条件码来判别测试条件，满足条件则转移到指令所指地址去执行，否则循环执行

#### 简单条件转移

根据单个标志位 SF,CF,ZF,OF,PF的值确定是否转移

`[标号:] 操作符 短标号`

1. JZ/JE 

   ZF = 1时，转移

   - JNZ/JNE

2. JS

   SF = 1时，转移

   - JNS

3. JO

   OF = 1时，转移

   - JNO

4. JC

   CF = 1时，转移

   - JNC

5. JP/JPE

   PF = 1时，转移

   - JNP/JPO

#### 无符号数条件转移指令

跟在比较指令之后，比较的对象为无符号数

- Above
- Below
- Equal

1. JA/JNBE 

   高于则转移 (CF = 0 & ZF = 0)

2. JAE/JNB 

   高于等于则转移 (CF = 0 | ZF = 1)

3. JB/JNAE 

   低于则转移 (CF = 1 & ZF = 0)

4. JBE/JNA

   低于等于则转移 (CF = 1 | ZF = 1)

#### 有符号条件转移指令

- greate
- little
- equal

1. JG / JNLE 

   大于则转移（当 SF=OF 且 ZF=0时，转移)

2. JGE / JNL  

   大于等于转移（当 SF=OF 或 ZF=1时，转移）

3. JL / JNGE  

   小于则转移（当 SF≠OF 且 ZF=0时，转移）

4. JLE / JNG  

   小于等于转移（当 SF≠OF 或 ZF=1时，转移）

### 无条件转移

1. JMP 标号

   段内直接

   (IP/EIP) + 位移量 -> IP/EIP

2. JMP OPD

   段内间接

   (OPD) -> IP/EIP

3. JMP 标号

   段间直接

   标号的EA -> IP/EIP

   段首址 -> CS

4. JMP OPD

   段间间接

   (OPD) -> IP/EIP

   (OPD+2/4) -> CS

### 带条件的数据传送

Conditional MOVe

`cmov** r32 r32/m32`

当`**`成立时，传送数据`(r32/m32) -> r32`

- r32

  表示一个32位寄存器

- m32

  表示一个内存地址

使用**单个**标志位判断

1. cmove/cmovz

   ZF = 1

   - cmovne/cmovnz

     ZF = 0

2. cmovc

   CF = 1

   - cmovnc

     CF = 0

3. cmovs

   SF = 1

   - cmovns

     SF = 0

4. cmovo

   OF = 1

   - cmovno

     OF = 0

5. cmovp

   PF = 1

   - cmovnp

     PF = 0

## 循环控制

### 计数控制

用于**循环次数已知**的情况

1. 正计数法

   计数值开始为0，每次循环+1，到n为止

   ```
   	MOV CX, 0
   	...
   L1:
   	...;循环体
   	INC CX
   	CMP CX, n ;控制部分
   	JNE L1
   ```

2. 倒计数法

   ```
   	MOV CX,n
   	...
   L1:
   	... ;循环体
   	DEC CX
   	JNZ L1 ;控制部分
   ```

### 条件控制

循环次数事先不知道

### 循环转移指令

1. LOOP 标号

   功能：`(CX/ECX) - 1 -> CX/ECX`

   若（CX / ECX)不为0，则转标号处执行。

   基本等价于：

   ```
   DEC CX / ECX
   JNZ 标号
   ```

2. LOOPE/LOOPZ 标号

   功能：`(CX/ECX) - 1 -> CX/ECX`

   若（CX / ECX)不为0，且ZF=1，则转标号处执行

3. LOOPNE/LOOPNZ 标号

   功能：`(CX / ECX) −1 → CX / ECX`

   若(CX/ECX)≠0，且ZF=0，则转标号处执行

4. JCXZ/JECXZ 标号

   功能：若（CX / ECX)为0，则转标号处执行。

   先判断，后执行循环体时，可用此语句，标号为循环结束处

## 堆栈

主存中的一片数据存储区

1. 进栈

   `PUSH OPS`

   OPS：寄存器，段寄存器，存储器

   功能：将OPS的**字**数据压入堆栈

   进栈活动

   - (SP) -2 -> SP
   - OPS -> [SP]

2. 出栈

   `POP OPD`

   OPD：寄存器，段寄存器(除CS)，存储器

   功能：将栈顶元素弹出到OPD

   出栈活动

   - ([SP]) -> OPD
   - (SP) + 2 -> SP

3. 8个16位寄存器进出栈

   `PUSHA`

   功能：将AX,CX,DX,BX,SP,BP,SI,DI按顺序入栈

   `POPA`

   功能：将AX,CX,DX,BX,SP,BP,SI,DI按相反顺序出栈

4. 8个32位寄存器进出栈

   `PUSHAD`

   功能：将EAXE,CX,EDX,EBX,ESP,EBP,ESI,EDI按顺序入栈

   `POPAD`

   功能：将EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI按相反顺序出栈

## 子程序

### 子程序的定义

```
子程序名 PROC [NEAR 或 FAR] [语言类型]
	...
	...
子程序名 ENDP
```

### 子程序的调用和返回

1. 调用指令 CALL

   调用范围

   - 段内 属性定义为 NEAR
   - 段外 属性定义为 FAR

   调用寻址方式

   - 直接
   - 间接

   1. 段内直接

      `CALL 过程名`

      功能：`(IP)➡⬇(SP)，目的地址EA➡IP`

   2. 段间直接

      `CALL FAR PTR 过程名`

      功能：`(CS)➡⬇(SP)，(IP)➡⬇(SP)`

      目的地址EA -> IP，目的地址段首址->CS

   3. 段内间接

      `CALL WORD PTR OPD`

      功能：`(IP)➡⬇(SP),(OPD)➡(IP)`

   4. 段间间接

      `CALL DOWRD PTR OPD`

      功能：`当前(CS)➡⬇(SP)，(IP)➡⬇(SP)`

2. 返回指令RET

   `RET` `RET n`

   功能：返回到调用指令的下一条指令处继续执行

   RET n 表示返回时清除栈顶的n个字

### 保护与恢复

调用子程序时，可能破坏原来寄存器的内容，因此需要进行保护

```
A	PROC
	PUSH BX
	PUSH AX
	...; 子程序
	POP AX
	POP BX
	RET
A	ENDP
```

### 参数传递

主程序为子程序提供入口参数，子程序返回结果给主程序

1. 寄存器法

   利用寄存器传送入口，出口参数

2. 约定单元法

   入、出口参数在事先约定的存贮单元中

3. 堆栈法

   利用堆栈传递参数


## C语言反汇编
